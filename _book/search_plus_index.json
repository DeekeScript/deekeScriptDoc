{"./":{"url":"./","title":"介绍","keywords":"","body":"DeekeScript介绍 DeekeScript是什么？ DeekeScript是一款基于Android无障碍的自动化脚本开发和打包软件（移动框架）。通过DeekeScript提供的接口，可以模拟用户操作、控制Android手机的APP。并且DeekeScript提供UI支持、卡密接口支持和SaaS卡密系统支持，开发者只需关注业务逻辑，只需要很短的时间就可以通过DeekeScript快速开发出各种商用应用。 DeekeScript优势有哪些？ DeekeScript是开发团队优化“嘀客APP”而开发出的一款底层框架。 “稳定”与“快”是DeekeScript的最大特点，也是DeekeScript的最大追求。DeekeScript将在未来提供强大的云市场，企业版用户可以自定义选择打包进自己的APP中。 采用JavaScript编写脚本，底层采用V8引擎，执行速度快 支持JSON格式定义主界面、参数设置界面等，开发者无需过多关注UI设计 支持Vscode开发与调试 支持全平台App（不针对主流App进行限制） 个人版完全免费使用 企业版支持后台卡密管理系统（支持代理模式，可私有化部署） 支持Android8（API26）以上 DeekeScript适合哪些场景？ 在绝大多数需要取代人工，或者模拟人工进行的操作，都可以采用DeekeScript解决方案。比如：某音自动化获客，某信自动打招呼等等 如果你想获得一个稳定性好，执行速度快的第三方移动开发框架 如果你想快速开发出自己的商用模拟控制软件 如果你想快速开发出美观拿得出手的APP 如果你想私有化部署自己的程序，而不想被其他第三方控制 如果你不懂程序，但是懂销售，想在互联网行业创造一番天地 如果你想... DeekeScript展望未来 未来，DeekeScript将会如何发展？我们在未来的6个月将会在以下几个地方发力： APP支持各种主题定制 丰富各种Api 开发应用市场 开发者可以将开发的功能发布在应用市场获取收益 用户只需要在DeekeScript软件内，即可使用软件内的使用插件） 商家在后台即可选择应用市场的任意功能进行打包，打造自己的App（支持私有化部署） window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-15 18:11:48 "},"demo/demo.html":{"url":"demo/demo.html","title":"案例篇","keywords":"","body":"案例篇 嘀客 嘀客（查看项目）作为DeekeScript工具开发的经典案例之一，具有参考价值；通过案例，可以让你了解到DeekeScript能做什么，以便你能够快速地做技术选型，开发“嘀客”需要做以下几步： 开发出这样的一款带App需要做哪些工作？ 电脑端下载Vscode，安装DeekeScript开发插件 拉取DeekeScript开发的基础代码 编写JavaScript脚本 设计几个图标（当然，也可以在iconfont.cn平台下载几个） 手机安装DeekeScript App软件 不断调试运行，确保代码文档、无bug 编写激活码后端Api（需要配置在DeekeScript中，便于你的打包后的App激活） 上传开发脚本，DeekeScript后台打包成App 此时你可以将打包后的App提供给你的客户群体去使用，将你的激活码提供给客户，客户即可使用你开发的App工具了。 如果你是企业用户（或者具备企业权限），你可能还需要以下功能： 在DeekeScript开放平台注册管理后台 将相关接口配置到DeekeScript开发环境中 DeekeScript后台支持贴牌代理模式，后台有三种角色，分别是平台、代理商、用户；平台可以开通代理商账号（分配激活码数量），代理商可以开通普通用户（分配激活码数量）和激活码，普通用户可以创建激活码； 因此，你可以把“代理商”看作这是“城市合伙人”， “用户”看作是“区域合伙人”，区域合伙人创建激活码给到终端用户使用。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/demo/demo.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/demo/demo.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-06 14:43:34 "},"quick/quick.html":{"url":"quick/quick.html","title":"认识DeekeScript","keywords":"","body":"快速入门 认识DeekeScript 为什么会有DeekeScript？早些年，我曾服务于国内某互联网公司，主导引流相关的业务；当时因为公司业务需要，想采用手机端运行脚本的方式执行引流操作，经过几天时间的全面调研，最终选择了国内小有名气的某开源脚本软件。 后来，我自己基于此开源软件打造了一款引流获客软件 — 嘀客APP。当然，现在的嘀客APP已经被迭代了好几个版本，个中心酸无以言表。 在嘀客APP产品运作过程中，技术团队遇到了太多奇怪的问题、不稳定、闪退、息屏等等。这些问题为我们开拓市场埋下了很大的隐患，甚至影响到产品的未来。 再后来，我们决定对嘀客APP进行重构，解决当前所有问题。我们发现要想解决这个根本问题，必须得开发自己的底层框架。否则根本问题无法解决。最终我们决定在2023年年底启动了DeekeScript项目，历时3个多月的时间，我们完成了DeekeScript的1.0版本，并且把原先的嘀客APP也迁移进DeekeScript了。现在嘀客APP的体验提升了很多，运行速度也大幅提升。不再有运行一段时间挂掉，或者无法识别到界面的节点等情况发生。 为什么选择DeekeScript？ DeekeScript为稳定而生，脚本在充电状态下，可以持续挂机，不会出现离奇的中断事件；更不会出现一段时间后无法识别APP界面节点等问题。结合我们这几年在创业过程中积累的经验，我们十分了解开发者需要什么； 并且我们还把原有的嘀客后台提供给开发者使用，开发者现在只需提供几个图标和几个JavaScript脚本文件，就可以快速打造一个创业项目。原本几个月才能完成的事情，现在只需要1-2天即可完成。我们把开发者遇到的坑都走了一遍，我们更懂得开发者的诉求！ window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/quick.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/quick.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-15 17:51:59 "},"quick/envir.html":{"url":"quick/envir.html","title":"开发环境说明","keywords":"","body":"开发环境说明 Android版本支持 DeekeScript对绝大多数Android版本都提供支持，主要支持Android 8.0及以上版本；对应的Android Api版本是26及以上。 Android权限说明 使用DeekeScript可以获取Android的哪些权限呢？ 目前DeekeScript不限制应用获取Android权限，只要Android开放的权限，DeekeScript都会开放；DeekeScript默认支持了大多数常用权限，对于DeekeScript默认不支持的权限，可以通过自定义权限方式获取（注意此方式，需要将开发脚本打包成App）。 JavaScript支持哪些能力？ DeekeScript底层是基于V8引擎的，V8 是 Google 的开源高性能 JavaScript 和 WebAssembly 引擎，用 C++ 编写。它用于 Chrome 和 Node.js 等。 因此不用担心DeekeScript支持JavaScript的功能不全的问题。 基础函数支持 很多同学之前可能了解浏览器环境下的JavaScript和nodejs，因此可能习惯了使用setTimeout、setInterval、console.log等方法，这些DeekeScript都从底层进行了实现；因此可以放心使用这些函数。 是否支持模块化 另外关注点更多的可能是模块化部分，因为DeekeScript本身就是为了支持项目化（针对某个或者某些应用开发N个脚本）开发的工具（而不仅仅只是支持单个脚本的开发），所以对模块化支持也是很友好的，具体可以参阅模块化 异步支持 DeekeScript提供了异步支持，具体参考DeekeScript异步 是否支持多线程？ 相信富有经验的开发者，会发现很多工具都有提供多线程支持；因为很多时候，我们需要同时执行两个操作（比如，采集直播间弹幕的时候，又要实时获取在线人数）；这个时候使用多线程的方式可以更好地满足我们的需求。DeekeScript本身也是支持多线程的；因为JavaScript是不支持多线程的，实际上底层是由Java在执行，具体可以参考多线程篇。 其他支持 类似http请求，websocket都有支持，具体可以参考文档对应部分 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/envir.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/envir.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-06 14:43:23 "},"quick/start.html":{"url":"quick/start.html","title":"快速开始","keywords":"","body":"快速开始 创建你的第一个JavaScript功能脚本 通过git获取基础代码 git clone https://github.com/DeekeScript/deekeScriptDemo.git ./ 打开Vscode代码编辑器，并且将刚刚克隆的项目打开 在Vscode中安装DeekeScript开发插件 在手机上下载安装DeekeScript软件包 打开DeekeScript的侧边栏，开启“无障碍”、“悬浮窗”权限 发送代码到手机（点击查看如何操作） 在Vscode中执行命令，让APP启动（或者在手机APP中点击“运行”） 手机中的APP已经出现了相应的界面，可以在手机中点击对应的功能进行运行 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/start.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/quick/start.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-03 09:51:31 "},"config/config.html":{"url":"config/config.html","title":"DeekeScript.json","keywords":"","body":"配置 deekeScript.json文件说明 示例请查看本页末尾部分 主体参数 参数名 类型 示例 说明 name String 嘀客 App安装成功之后，在手机上的名称 icon String logo/dke.png 图标建议采用200*200像素的，清晰度大的 head String img/root.png App中用户设置页面的头像，无设置页可以不填 settingTopBg String img/sett-top.png App中用户设置页面的背景图，可以不设置，但是建议设置 methods Json methods参数 主界面的功能列表，每一个子节点对应一个功能 bottomMenus Json bottomMenus参数 App中底部菜单，可以使用系统内置的，也可以自定义 settingLists Json settingLists参数 App中设置页的列表项，可以使用系统内置的，也可以自定义 apis Json apis参数 设置相关api，比如激活码api，验证激活码是否有效api登 methods参数 参数名 类型 示例 说明 title String XX截流 App主界面的功能名称 icon String logo/fans.png App主界面的功能图标 jsFile String tasks/task_dy_toker_fans.js 功能实际执行的代码所在文件 settingPage Json settingPage参数 功能对应的设置页面，如果为空，则直接执行jsFile脚本 hidden boolean true 属性值，当为true的时候，则界面上不再显示此功能模块 bottomMenus参数 参数名 类型 示例 说明 title String 首页 底部菜单名称名称 icon String logo/fans.png 底部菜单图标 banner String banner/banner.png type为home的时候生效，首页顶部图片 type String home 目前支持home、setting、speech，分别表示首页、设置页、话术页 settingLists参数 参数名 类型 示例 说明 title String 清理缓存 设置页标题名称 icon String logo/clear.png 底部菜单图标 url String https://script.deeke.top/upload/log type为uploadLog的时候，必须，用于接受上传日志 type String clear 支持clear、uploadLog、customerService、updateApp、custom，分别表示 清理缓存、上传日志、联系客服、更新App、自定义 jsFile String home type为custom的时候必须，点击的时候，会执行对应的js文件 description String 确定清理吗？ type为clear的时候，会弹出提示框，确认后执行清理；type为customerService可以设置为“客服微信：miniphper” apis参数 参数名 类型 示例 说明 url String https://script.deeke.top/api/login 接口地址，type为bind，则为激活码激活地址；type为checkBind，则为激活码验证地址 type String bind 目前支持bind、checkBind，bind为首次激活，checkBind用于每次运行功能时执行检查，状态不对则无法运行功能，并会给出提示 settingPage参数 参数名 类型 示例 说明 params Json params参数 需要用户设置的参数 params参数 参数名 类型 示例 说明 type String text Form参数类型，有text、textArea、select、checkbox、radio、switch、number、numberRange、digitRange、digit lable String 用户账号 字段描述，控件的描述，用于告诉用户这个控件输入的内容 value any miniphper 初始值，可以为空 ; number/numberRange/digitRange/digit的时候，value为数字类型，text/textArea为字符串类型 name String account 控件名称，后续获取值的时候，需要这个参数名称 min int 0 最小值，当type为numberRange或者digitRange时生效 max int 1000 最大值，当type为numberRange或者digitRange时生效 step int 1 滑动最小单位，当type为numberRange或者digitRange时生效 options Json options参数 属性值，当type为select、checkbox、radio时生效 hidden boolean true 属性值，当为true的时候，则界面上不再显示此字段 options参数 参数名 类型 示例 说明 selected bool false 是否默认选中 lable String 男 描述，用于告诉用户这个控件的内容 value String 1 值 { \"name\": \"嘀客\", \"icon\": \"logo/dke.png\", \"head\": \"img/robot.png\", \"settingTopBg\": \"img/setting-top.png\", \"methods\": [ { \"title\": \"XX截流\", \"icon\": \"img/fans.png\", \"jsFile\": \"tasks/task_dy_toker_fans.js\", \"settingPage\": { \"jsFile\": \"page/fans.js\", \"params\": [ {type:\"text\", lable:\"账号\", name:\"account\", \"value\":\"miniphper\"}, {type:\"digit\", lable:\"执行次数\", name:\"times\", \"value\":100}, {type:\"numberRange\", lable:\"最小作品数\", name:\"works_count\", \"value\":100, min: 0, max: 10000, step: 1}, {type:\"digitRange\", lable:\"私信评率\", name:\"pri_msg_rate\", \"value\":0.5, max: 1, min: 0}, {type:\"checkbox\", lable:\"性别\", name:\"private_msg_rate\", options: [ {lable: \"男\", value: 1, selected: true}, {lable: \"女\", value: 0, selected: true}, {lable: \"未知\", value: 2, selected: false}, ]}, {type:\"switch\", lable:\"点赞头像\", name:\"zan_avatar\", value: true}, ] } }, { \"title\": \"XXX截流\", \"icon\": \"img/anchor_focus.png\", \"jsFile\": \"tasks/task_dy_toker_focus.js\" } ], \"bottomMenus\": [ { \"title\": \"嘀客\", \"icon\": \"img/home.png\", \"banner\": \"img/home-top.png\", \"type\": \"home\" }, { \"title\": \"话术设置\", \"icon\": \"img/speech.png\", \"type\": \"speech\" }, { \"title\": \"系统设置\", \"icon\": \"img/setting.png\", \"type\": \"setting\" } ], \"settingLists\": [ { \"title\": \"联系客服\", \"icon\": \"img/kefu.png\", \"type\": \"customerService\", \"description\": \"客服微信：miniphper\" }, { \"title\": \"上传日志\", \"icon\": \"img/upload.png\", \"type\": \"uploadLog\", \"url\": \"https://top.deeke.script/uploadLog\" }, { \"title\": \"系统升级\", \"icon\": \"img/update.png\", \"type\": \"updateApp\", \"url\": \"https://top.deeke.script/updateApp\" }, { \"title\": \"清理数据\", \"icon\": \"img/clear.png\", \"description\": \"确定清理嘛？\", \"type\": \"clear\" }, { \"title\": \"自定义功能\", \"icon\": \"img/clear.png\", \"type\": \"custom\", \"jsFile\": \"app/custom.js\" } ], \"api\": [ { \"type\": \"login\", \"url\": \"https://top.deeke.script/login\" }, { \"type\": \"checkLogin\", \"url\": \"https://top.deeke.script/isLogin\" } ] } window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/config/config.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/config/config.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-02 15:55:10 "},"config/vscode.html":{"url":"config/vscode.html","title":"Vscode开发篇","keywords":"","body":"VSCode开发篇 Vscode配置 下载安装Vscode编辑器 可以通过官网地址下载：https://code.visualstudio.com/ 安装DeekeScript扩展 点击vscode左侧的“扩展”图标，输入DeekeScript，然后列表中有一个DeekeScript扩展，点击安装即可 Vscode扩展使用 发送项目到手机 打开“查看”-“命令面板”，输入“XXX”，确定执行 执行手机上的项目 打开“查看”-“命令面板”，输入“XXX”，确定执行 暂停手机上的程序 打开“查看”-“命令面板”，输入“XXX”，确定执行 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/config/vscode.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/config/vscode.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-02 16:46:46 "},"base/app/app.html":{"url":"base/app/app.html","title":"App","keywords":"","body":"App App对象提供了一些应用相关的数据获取能力，比如当前App的版本号、获取某个App的版本等。 currentPackageName 返回 {string} 获取当前应用的包名，获取你当前开发的App的包名，比如在DeekeScript中执行这个函数，将获取到“top.deeke.script” console.log(App.currentPackageName());//输出 top.deeke.script currentVersionCode 返回 {number} 整型 返回当前App的版本号，这个在App更新的时候判断当前App的版本号时很有用 currentVersionName 返回 {string} 返回当前App的版本名称 packageInfo 返回 {PackageInfo} 返回当前App的包信息，通过包信息你可以获取诸如“版本号，版本名称”等信息，可以遍历查看其属性和值 intent(json) json {json} 返回 {Intent} 创建Intent，也可以使用 new Intent();方式来创建 startActivity(object) options {object} 返回 {void} 根据选项构造一个Intent，并启动启动Activity //打开应用来查看图片文件 var i = App.intent({ action: \"VIEW\", type: \"image/png\", data: \"file:///sdcard/1.png\" }); context.startActivity(i); startService(options) options {object} 返回 {CompnentName} 根据选项构造一个Intent，并启动该服务。 sendBroadcast(options) options {object} 返回 {CompnentName} 根据选项构造一个Intent，并发送该广播。 launch(packageName) packageName {string} 通过包名打开应用 App.launch(\"top.deeke.script\");//打开DeekeScript openAppSetting(packageName) packageName {string} 通过包名，打开设置页面，在此页面可以无障碍点击卸载和强制停止按钮（停止应用的时候，很管用） notifySuccess(title, content) title {string} content {string} 返回 {Notification} 通过Android的通知来告知用户，当前脚本已经执行完成，并且关闭当前启动的功能 如果只是通知完成，但是不关闭当前脚本，请自定义通知实现 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/app/app.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/app/app.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 18:08:14 "},"base/system/funcs.html":{"url":"base/system/funcs.html","title":"系统函数","keywords":"","body":"系统函数 - System System对象，提供一些常用的方法。 sleep(millisecond) millisecond {number} 毫秒 休眠millisecond毫秒 console.log('立即输出'); System.sleep(1000); console.log('1秒钟后输出'); time() 返回 {string} 返回当前系统时间 console.log(System.time());//输出：2024-03-07 12:12:12 currentActivity() 返回 {string} 返回最近一次监测到的正在运行的Activity名称，一般可以认为就是当前正在运行的Activity的名称。 此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。 console.log(System.currentActivity());//输出：top.deeke.script currentPackage() 返回 {string} 返回最近一次监测到的正在运行的Package的名称，一般可以认为就是当前正在运行的Package的名称。 此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。 console.log(System.currentPackage());//输出：top.deeke.script setClip(content) content {string} 返回 {void} 将内容写入到剪切板中 getClip() 返回 {string|null} 返回剪切板内容 toast(message) msg {string} 要显示的信息 返回 {void} 以气泡显示信息message几秒。(具体时间取决于安卓系统，一般都是2秒) 注意，信息的显示是\"异步\"执行的，并且，不会等待信息消失程序才继续执行。 toastLong(message) msg {string} 要显示的信息 返回 {void} 比toast(message)显示的更久一些，具体时长以开发机为准 注意，信息的显示是\"异步\"执行的，并且，不会等待信息消失程序才继续执行。 waitForActivity(activity, period, timeout) activity {string} 等待的Activity名称 period {number} 等待的毫秒数 timeout {number} 等待的总毫秒数 返回 {void} 等待Activity出现，period为检查Activity的间隔。如果timeout毫秒后未出现，则停止等待。 waitForPackage(package, period, timeout) package {string} 等待的Package名称 period {number} 等待的毫秒数 timeout {number} 等待的总毫秒数 返回 {void} 等待Package出现，period为检查Package的间隔。如果timeout毫秒后未出现，则停止等待。 exit(closeAll) closeAll {boolean} 是否关闭所有脚本引擎，为true则关闭所有，否则只关闭当前引擎外的其他脚本引擎 返回 {void} 关闭脚本引擎 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/system/funcs.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/system/funcs.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 10:09:29 "},"base/device/device.html":{"url":"base/device/device.html","title":"设备-Device","keywords":"","body":"设备 - Device Device对象，提供一些设备相关的方法。 keepScreenOn(seconds) seconds {number} 屏幕常量秒数 返回 {void} 屏幕常量，如果seconds为0，则亮屏10分钟，否则亮屏seconds秒。seconds最大值可能在不同设备上有一定限制。 保证屏幕常量，一般在操作（操作过程中，屏幕一般不会息屏）完相关步骤后，回到我们的App应用（在我们自己的应用上，可以保证长时间不息屏），即可保证不会息屏 Device.keepScreenOn(600);//常量10分钟 closeScreenLight() 返回 {void} 常量关闭 width() 返回 {number} 返回宽度 单位为px 获取屏幕真实的宽度（像素值）；手机旋转方向后，依然会返回真实的宽度 height() 返回 {number} 返回宽度 单位为px 获取屏幕真实的高度（像素值）；手机旋转方向后，依然会返回真实的高度 sdkInt() 返回 {number} 返回SDK的版本号 device() 返回 {string} 请注意，这个返回值并不是设备的市场名称（如“华为荣耀V30”）、品牌名（如“华为”）或型号名（如“V30”）。它更偏向于一个内部或技术名称，用于在Android框架和开发中识别不同的设备硬件。 获取设备的硬件标识，比如华为荣耀，可能返回\"honor_xxx\"的字符串 androidVersion() 返回 {string} 返回Android的版本号 createUuid() 返回 {string} 由于Android日益严格的权限管控，导致设备的唯一标识不太方便获取，本系统提供了一个uuid生成方案，来解决设备识别问题；建议在开发者在用户激活设备之后，使用此方法创建一个uuid（创建前，请使用getUuid检查是否存在）；后续将这个唯一标识和激活码绑定； 注意：App卸载后、设备恢复出厂等操作，将会让生成的uuid丢失 设置设备的随机的uuid getUuid() 返回 {string} 获取设备的随机的uuid isScreenOn() 返回 {boolean} 获取屏幕是否亮屏 brand() 返回 {string} 获取设备的品牌信息；对于华为（Huawei）的设备，它会返回 \"huawei\"。 os() 返回 {string} 获取设备操作系统信息；对于大多数标准的 Android 设备，Build.VERSION.BASE_OS 通常返回 \"android\"。然而，在某些设备或定制 Android 版本中，制造商可能会为其定制的基础操作系统设置不同的名称或标识符。 model() 返回 {string} 获取设备的model信息；如：荣耀特定设备的型号名称，如 \"Honor V30\" 或类似的字符串 codename() 返回 {string} 获取设备的codename信息；例如 \"REL\" 表示正式发布的版本 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/device/device.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/device/device.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-07 15:57:32 "},"base/uiSelector/uiSelector.html":{"url":"base/uiSelector/uiSelector.html","title":"选择器-UiSelector","keywords":"","body":"选择器 - UiSelector 基本介绍 UiSelector 即选择器，用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作。这里需要先简单介绍一下控件和界面的相关知识。 Android中的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控件的位置，例如，线性布局(LinearLayout)里面的控件都是按水平或垂直一次叠放的，列表布局(AbsListView)则是以列表的形式显示控件。 控件有各种属性，包括文本(text), 描述(desc), 类名(className)，是否可以点击（clickable）, id 等等。我们通常用一个控件的属性来找到这个控件，例如，想要点击某软件聊天窗口的\"发送\"按钮，我们就可以通过他的文本属性为\"发送\"来找到这个控件并点击他，具体代码为: 获取控件后，即可对控件进行点击，滑动，输入文本等操作。控件操作请阅读 控件操作 部分 //这里的sendButton就是一个控件对象，可以对控件对象进行各种操作 let sendButton = new UiSelector().text(\"发送\").findOne(); if(sendButton){ sendButton.click(); } id(name) name {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"id 等于字符串 name\"的筛选条件。 className(name) name {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"className 等于字符串 name\"的筛选条件。 bounds(left, top, right, bottom) left {number} 控件左边缘与屏幕左边的距离 top {number} 上边距 right {number} 右边距 bottom {number} 下边距 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"bounds范围\"的筛选条件。 text(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"text 等于字符串 content\"的筛选条件。 desc(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"contentDescribe 等于字符串 content\"的筛选条件。 clickable(canClick) canClick {boolean} 是否可以点击 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"clickable 等于 canClick\"的筛选条件。 isVisibleToUser(canVisible) canVisible {boolean} 是否对用户可见（控件在屏幕上） 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"isVisibleToUser 等于 canVisible\"的筛选条件。 selected(isSelected) isSelected {boolean} 是否已选择 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"selected 等于 isSelected\"的筛选条件。 checked(isChecked) isChecked {boolean} 是否被选中 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"checked 等于字符串 isChecked\"的筛选条件。 enabled(isEnabled) isEnabled {boolean} 是否可以交互（为false的时候表示禁用） 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"enabled 等于字符串 isEnabled\"的筛选条件。 scrollable(canScrollable) canScrollable {boolean} 是否可以滚动 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"scrollable 等于字符串 canScrollable\"的筛选条件。 checkable(isCheckable) isCheckable {boolean} 是否可以选中 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"checkable 等于字符串 isCheckable\"的筛选条件。 textContains(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"text 包含字符串 content\"的筛选条件。 textMatches(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"text 正则匹配 content\"的筛选条件。 descContains(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"contentDescribe 正则匹配 content\"的筛选条件。 descMatches(content) content {string} 返回 {UiSelector} 返回选择器自身以便链式调用 为当前选择器附加控件\"contentDescribe 正则匹配 content\"的筛选条件。 filter(callback) callback {function} 返回{UiObject[]} 对当前查找到的UiObject数组进行过滤，过滤的时候执行callback方法，该方法返回false，则对应的UiObject被过滤掉 exist() content {string} 返回 {boolean} 返回是否存在 判断当前选择器是否能匹配到UiObject控件信息。 find() 返回 {UiObject[]} 获取当前选择器筛选的所有UiObject控件。 find(uiSelector) uiSelector {UiSelector} 返回 {UiObject[]} 获取当前选择器筛选的所有UiObject控件（a）中查找符合uiSelector选择器的UiObject；从a集合查找，然后遍历它们的子控件、子控件的子控件，直到a下面的所有控件都被查找一遍才结束。 find(timeout) timeout {number} 返回 {UiObject[]} 获取当前选择器筛选的所有UiObject控件，查找timeout时间，时间结束后不管是否找到，都会结束查找，并且返回。 findOne() 返回 {UiObject} 获取当前选择器筛选的第一个UiObject控件。 findOnce() 返回 {UiObject} 获取当前选择器筛选的第一个UiObject控件。 findOne(uiSelector) uiSelector {UiSelector} 返回 {UiObject} 获取当前选择器筛选的第一个UiObject控件（a）中查找符合uiSelector选择器的UiObject；从a集合查找，然后遍历它们的子控件、子控件的子控件，直到a下面的所有控件都被查找一遍才结束。 find(timeout) timeout {number} 返回 {UiObject} 获取当前选择器筛选的第一个UiObject控件，查找timeout时间，时间结束后不管是否找到，都会结束查找，并且返回。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/uiSelector/uiSelector.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/uiSelector/uiSelector.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-14 11:17:37 "},"base/timer/timer.html":{"url":"base/timer/timer.html","title":"定时器","keywords":"","body":"定时器 用于在未来某个未来时间执行函数；计时器函数实现了与 Web 浏览器提供的定时器类似的 API。 setTimeout(callback, delay) callback {callback} 要执行的函数 delay {number} 延时 毫秒数 示例： setTimeout(()=>{ console.log('2秒后执行'); }, 2000); setInterval(callback, delay) callback {callback} 要执行的函数 delay {number} 延时 毫秒数 示例： setInterval(()=>{ console.log('每间隔2秒执行一次'); }, 2000); setImmediate(callback) callback {callback} 要执行的函数 在Looper循环的当前回合结束时要调用的函数 示例： setImmediate(()=>{ console.log('脚本最后执行'); }); clearTimeout(id) 取消一个由setTimeout(callback, delay)创建的定时任务 示例： let timer = setTimeout(()=>{ console.log(123); }, 1000); clearTimeout(timer); clearInterval(id) 取消一个由setInterval(callback, delay)创建的定时任务 示例： let timer = setInterval(()=>{ console.log(123); }, 1000); clearInterval(timer); clearImmediate(id) 取消一个由setImmediate(callback, delay)创建的定时任务 示例： let timer = setImmediate(()=>{ console.log(123); }); clearImmediate(timer); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/timer/timer.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/timer/timer.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 10:11:02 "},"base/http/http.html":{"url":"base/http/http.html","title":"Http","keywords":"","body":"网络请求-Http Http模块提供一些进行http请求的函数。 get(url, headers) url {string} 请求地址 headers {json} 请求头 可以为 null let res = Http.get('https://script.deeke.top/api/userInfo'); console.log(res);//输出 {code: 0, msg: \"成功\", data: {name: \"miniphper\", weixin: \"miniphper\"}} post(url, params, headers) url {string} 请求地址 params {json} 请求参数 headers {json} 请求头 可以为 null post请求的Content-type为\"application/json; charset=utf-8\" let params = { account: \"miniphper\", password: \"miniphper\" } let res = Http.post('https://script.deeke.top/api/login', params, null); console.log(res);//输出 {code: 0, msg: \"成功\", data: []} postFile(url, files, params, callback) url {string} 请求地址 files {File[]} 请求文件列表 params {json} 请求参数 headers {json} 请求头 可以为 null let files = [new File(\"文件地址\"), new File(\"文件地址2\")]; let params = {username: \"miniphper\"}; let res = Http.postFile('https://script.deeke.top/api/fileUpload', files, params, { success: (response)=>{ //处理逻辑 let js = response.json(); console.log(js); }, fail: (response)=>{ //失败逻辑 } }); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/http/http.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/http/http.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 10:08:37 "},"base/webSocket/webSocket.html":{"url":"base/webSocket/webSocket.html","title":"WebSocket","keywords":"","body":"webSocket create 后续更新 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/webSocket/webSocket.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/webSocket/webSocket.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:13:24 "},"base/console/console.html":{"url":"base/console/console.html","title":"控制台-console","keywords":"","body":"控制台 - console 控制台模块提供了一个和Web浏览器中相似的用于调试的控制台。用于输出一些调试信息、中间结果等。 console模块中的一些函数也可以直接作为全局函数使用，例如log, info等。 如果你不仅仅需要打印数据到控制台，还需要记录日志到文件，请使用 日志-Log 相关的方法 注意：console是DeekeScript中唯一一个首字母小写的对象（为了适应用户习惯） log([data][, ...args]) 打印到控制台，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。 console.log(\"输出的内容\", 324, {name: \"张三\"}); info([data][, ...args]) 与console.log类似，但输出结果以绿色字体显示。输出优先级高于log, 用于输出重要信息。 warn([data][, ...args]) 与console.log类似，但输出结果以蓝色字体显示。输出优先级高于info, 用于输出警告信息。 error([data][, ...args]) 与console.log类似，但输出结果以红色字体显示。输出优先级高于warn, 用于输出错误信息。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/console/console.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/console/console.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-07 15:59:51 "},"base/log/log.html":{"url":"base/log/log.html","title":"日志-Log","keywords":"","body":"日志 - Log 日志模块提供了一些日志写入方法，例如log, info等。 如果你不仅仅需要打印数据到控制台，还需要记录日志到文件，请使用Log相关的方法 setFile(filename); 设置日志输出文件 //未打包：最终存储在 /data/data/top.deeke.script/files/log/myfile.log //打包后：最终存储在 /data/data/com.example.myapp/files/log/myfile.log Log.setFile(\"myfile.log\"); getFileDir(filename); 获取日志文件完整路径 let filename = Log.getFileDir(\"myfile.log\"); //未打包：返回内容为 /data/data/top.deeke.script/files/log/myfile.log //打包后：返回内容为 /data/data/com.example.myapp/files/log/myfile.log Log.log(filename); log([data][, ...args]) 与console.log类似，区别是会记录输出内容到文件。 info([data][, ...args]) 与console.info类似，区别是会记录输出内容到文件。 warn([data][, ...args]) 与console.warn类似，区别是会记录输出内容到文件。 error([data][, ...args]) 与console.error，区别是会记录输出内容到文件。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/log/log.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/log/log.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-07 15:59:01 "},"base/storage/storage.html":{"url":"base/storage/storage.html","title":"本地存储","keywords":"","body":"本地存储 本地存储模块提供了一些数据写入和读取的功能。 存储模块底层使用的Android DataStore实现 createDataStore(namespace); namespace {string} 返回 {boolean} 设置存储文件，不同模块可以设置不同的namespace 【对应Android中的filename】 注意：前缀为\"deekeScript:XXX\"的namespace被系统使用，用户只能读取不能写入 Storage.createDataStore(namespace); put(key, value); key {string} value {any} 返回 {boolean} let user = { name: \"张三\", age: 22 }; Storage.put(\"user\", user); get(key); key {string} 返回 {any} 输出键为key的值，不存在的时候返回null let user = Storage.get(\"user\"); Log.log(user);//输出json数据 {name: \"张三\", age: 22} remove(key); key {string} 返回 {boolean} 存在则删除，不存在则什么都不做 let user = Storage.remove(\"user\"); Log.log(Storage.get(\"user\"));//输出 null clear(); 返回 {boolean} 清空所有内容 Log.log(Storage.clear());//输出 true window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/storage/storage.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/storage/storage.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 10:09:03 "},"base/files/files.html":{"url":"base/files/files.html","title":"文件系统-Files","keywords":"","body":"Files Files模块提供了一些常见的文件处理，包括文件读写、移动、复制、删掉等。 一次性的文件读写可以直接使用Files.read(), Files.write(), Files.append()等方便的函数; isFile(path) path {string} 路径 返回 {boolean} 返回路径path是否是文件。 console.log(Files.isDir(\"/sdcard/文件夹/\")); //返回false console.log(Files.isDir(\"/sdcard/文件.txt\")); //返回true isDir(path) path {string} 路径 返回 {boolean} 返回路径path是否是文件夹。 console.log(Files.isDir(\"/sdcard/文件夹/\")); //返回true console.log(Files.isDir(\"/sdcard/文件.txt\")); //返回false isEmptyDir(path) path {string} 路径 返回 {boolean} 返回文件夹path是否为空文件夹。如果该路径并非文件夹，则直接返回false。 join(parent, child) parent {string} 父目录路径 child {string} 子路径 返回 {string} 连接两个路径并返回，例如Files.join(\"/sdcard/\", \"1.txt\")返回\"/sdcard/1.txt\"。 create(path) path {string} 路径 返回 {boolean} 创建一个文件或文件夹并返回是否创建成功。如果文件已经存在，则直接返回false。 createWithDirs(path) path {string} 路径 返回 {boolean} 创建一个文件或文件夹并返回是否创建成功。如果文件所在文件夹不存在，则先创建他所在的一系列文件夹。如果文件已经存在，则直接返回false。 exists(path) path {string} 路径 返回 {boolean} 返回在路径path处的文件是否存在。 ensureDir(path) path {string} 路径 确保路径path所在的文件夹存在。如果该路径所在文件夹不存在，则创建该文件夹。 例如对于路径\"/sdcard/Download/ABC/1.txt\"，如果/Download/文件夹不存在，则会先创建Download，再创建ABC文件夹。 read(path[, encoding = \"utf-8\"]) path {string} 路径 encoding {string} 字符编码，可选，默认为utf-8 返回 {string} 读取文本文件path的所有内容并返回。如果文件不存在，则抛出FileNotFoundException。 readBytes(path) path {string} 路径 返回 {byte[]} 读取文件path的所有内容并返回一个字节数组。如果文件不存在，则抛出FileNotFoundException。 write(path, text[, encoding = \"utf-8\"]) path {string} 路径 text {string} 要写入的文本内容 encoding {string} 字符编码 把text写入到文件path中。如果文件存在则覆盖，不存在则创建。 writeBytes(path, bytes) path {string} 路径 bytes {byte[]} 字节数组，要写入的二进制数据 把bytes写入到文件path中。如果文件存在则覆盖，不存在则创建。 append(path, text[, encoding = 'utf-8']) path {string} 路径 text {string} 要写入的文本内容 encoding {string} 字符编码 把text追加到文件path的末尾。如果文件不存在则创建。 appendBytes(path, text[, encoding = 'utf-8']) path {string} 路径 bytes {byte[]} 字节数组，要写入的二进制数据 把bytes追加到文件path的末尾。如果文件不存在则创建。 copy(fromPath, toPath) fromPath {string} 要复制的原文件路径 toPath {string} 复制到的文件路径 返回 {boolean} 复制文件，返回是否复制成功。例如Files.copy(\"/sdcard/1.txt\", \"/sdcard/Download/1.txt\")。 move(fromPath, toPath) fromPath {string} 要移动的原文件路径 toPath {string} 移动到的文件路径 返回 {boolean} 移动文件，返回是否移动成功。例如Files.move(\"/sdcard/1.txt\", \"/sdcard/Download/1.txt\")会把1.txt文件从sd卡根目录移动到Download文件夹。 rename(path, newName) path {string} 要重命名的原文件路径 newName {string} 要重命名的新文件名 返回 {boolean} 重命名文件，并返回是否重命名成功。例如Files.rename(\"/sdcard/1.txt\", \"2.txt\")。 renameWithoutExtension(path, newName) path {string} 要重命名的原文件路径 newName {string} 要重命名的新文件名 返回 {boolean} 重命名文件，不包含拓展名，并返回是否重命名成功。例如Files.rename(\"/sdcard/1.txt\", \"2\")会把\"1.txt\"重命名为\"2.txt\"。 getName(path) path {string} 路径 返回 {string} 返回文件的文件名。例如Files.getName(\"/sdcard/1.txt\")返回\"1.txt\"。 getNameWithoutExtension(path) path {string} 路径 返回 {string} 返回不含拓展名的文件的文件名。例如## getName(\"/sdcard/1.txt\")返回\"1\"。 getExtension(path) path {string} 路径 返回 {string} 返回文件的拓展名。例如Files.getExtension(\"/sdcard/1.txt\")返回\"txt\"。 remove(path) path {string} 路径 返回 {boolean} 删除文件或空文件夹，返回是否删除成功。 removeDir(path) path {string} 路径 path {string} 路径 返回 {boolean} 删除文件夹，如果文件夹不为空，则删除该文件夹的所有内容再删除该文件夹，返回是否全部删除成功。 getSdcardPath() 返回 {string} 返回SD卡路径。所谓SD卡，即外部存储器。 cwd() 返回 {string} 返回脚本的\"当前工作文件夹路径\"。该路径指的是，如果脚本本身为脚本文件，则返回这个脚本文件所在目录；否则返回null获取其他设定路径。 例如，对于脚本文件\"/sdcard/脚本/1.js\"运行Files.cwd()返回\"/sdcard/脚本/\"。 path(relativePath) relativePath {string} 相对路径 返回 {string} 返回相对路径对应的绝对路径。例如Files.path(\"./1.png\")，如果运行这个语句的脚本位于文件夹\"/sdcard/脚本/\"中，则返回\"/sdcard/脚本/1.png\"。 listDir(path[, filter]) path {string} 路径 filter {Function} 过滤函数，可选。接收一个string参数（文件名），返回一个boolean值。 列出文件夹path下的满足条件的文件和文件夹的名称的数组。如果不加filter参数，则返回所有文件和文件夹。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/files/files.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/files/files.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 15:14:27 "},"base/gesture/gesture.html":{"url":"base/gesture/gesture.html","title":"手势操作","keywords":"","body":"手势 - Gesture click(x, y) x {number} x轴坐标 y {number} y轴坐标 返回 {boolean} 点击屏幕位置 Gesture.click(100, 200); longClick(x, y) x {number} x轴坐标 y {number} y轴坐标 返回 {boolean} 长按屏幕位置 Gesture.longClick(100, 200); press(x, y, duration) x {number} x轴坐标 y {number} y轴坐标 duration {number} 按压时间 毫秒 返回 {boolean} 按压屏幕位置一段时间 Gesture.press(100, 200, 10);//每次按压10毫秒 swipe(startX, startY, endX, endY, duration) startX {number} 开始位置的x轴坐标 startX {number} 开始位置的y轴坐标 endX {number} 结束位置的x轴坐标 endY {number} 结束位置的y轴坐标 duration {number} 滑动时间 毫秒 返回 {boolean} 滑动手势 Gesture.swipe(100, 200, 500, 400, 200);//从坐标（100,200）滑动到（500，400），执行时间为200毫秒 back() 返回 {boolean} 点击返回按键 Gesture.back(); home() 返回 {boolean} 点击Home按键，返回到主界面 Gesture.home(); recents() 返回 {boolean} 显示最近任务 Gesture.back(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/gesture/gesture.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/gesture/gesture.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-14 11:07:51 "},"base/uiObject/uiObject.html":{"url":"base/uiObject/uiObject.html","title":"控件操作","keywords":"","body":"控件操作 基本介绍 UiObject 即控件对象，可以对控件进行点击、长按等动作。这里需要先简单介绍一下控件的相关知识。 Android中的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控件的位置。 获取控件后，即可对控件进行点击，滑动，输入文本等操作。获取控件操作请阅读 获取控件操作 部分 //这里的sendButton就是一个控件对象，可以对控件对象进行各种操作 let sendButton = new UiSelector().text(\"发送\").findOne(); if(sendButton){ sendButton.click(); } click() 返回 {Boolean} 返回是否点击成功 点击控件 let sendButton = new UiSelector().text(\"发送\").findOne(); if(sendButton){ sendButton.click(); } longClick() 返回 {Boolean} 返回是否点击成功 点击控件 let sendButton = new UiSelector().text(\"发送\").findOne(); if(sendButton){ sendButton.longClick(); } scrollForward() 返回 {Boolean} 返回是否滑动成功 向前滑动控件，将会让界面下方的节点往上滚动或者右边的节点往左滚动 scrollBackward() 返回 {Boolean} 返回是否滑动成功 向后滑动控件，将会让界面上方的节点往下滚动或者左边的节点往右滚动 setSelection(startPosition, endPosition) startPosition {number} 起始位置 endPosition {number} 结束位置 返回 {Boolean} 返回是否成功 选中文本内容 copy() 返回 {Boolean} 返回是否成功 复制选中的文本内容 let et = new UiSelector().className(\"EditText\").findOne(); //选中前两个字 et.setSelection(0, 2); //对选中内容进行复制 if(et.copy()){ toast(\"复制成功\"); }else{ toast(\"复制失败\"); } cut() 返回 {boolean} 返回是否成功 对输入框文本的选中内容进行剪切，并返回是否操作成功。 该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过setSelection()函数来设置输入框选中的内容。 paste() 返回 {boolean} 返回是否成功 粘贴内容到文本框 System.setClip(\"DeekeScript\");//将字符串“DeekeScript”粘贴到文本框 let obj = new UiSelector().className(\"EditText\").findOne(); obj.paste(); focus() 返回 {boolean} 返回是否成功 获取焦点。 let obj = new UiSelector().className(\"EditText\").findOne(); obj.focus(); setText(text) text {string} 输入参数 返回 {boolean} 返回是否成功 将字符串“text”输入到文本框 let obj = new UiSelector().className(\"EditText\").findOne(); obj.setText(\"DeekeScript\");//将字符串“DeekeScript”输入到文本框 find(uiSelector) uiSelector {UiSelector} 要查找的内容 返回 {UiObject[]|null} 返回查找到的控件对象 在当前的控件下查找某些控件，查找条件通过UiSelector定义 let obj = new UiSelector().className(\"name\").findOne(); let uiObjects = obj.find(new UiSelector().className(\"EditText\"));//查找obj下面的所有输入框控件 findOne(uiSelector) uiSelector {UiSelector} 要查找的内容 返回 {UiObject|null} 返回查找到的控件对象 在当前的控件下查找某个控件，查找条件通过UiSelector定义 let obj = new UiSelector().className(\"name\").findOne(); let uiObject = obj.findOne(new UiSelector().className(\"EditText\"));//查找obj下面的第一个输入框控件 bounds() 返回 {Rect} 返回当前控件的位置信息 let obj = new UiSelector().className(\"EditText\").findOne(); let rect = obj.bounds(); //输出 左边距、上边距、右边距、下边距、高度、宽度 console.log(rect.left, rect.top, rect.right, rect.bottom, rect.height(), rec.width()); id() 返回 {string} 返回当前控件的id let obj = new UiSelector().id(\"p2\").findOne(); let str = obj.id();//输出p2 text() 返回 {string} 返回当前控件的text内容 let obj = new UiSelector().id(\"p2\").findOne(); let str = obj.text();//控件的text属性获取 desc() 返回 {string} 返回当前控件的contentDescription内容 let obj = new UiSelector().id(\"p2\").findOne(); let str = obj.desc();//控件的contentDescription属性获取 children() 返回 {UiObject[]|null} 返回当前控件的所有子控件对象 let obj = new UiSelector().id(\"p2\").findOne(); let childs = obj.children();//子控件内容 parent() 返回 {UiObject} 返回当前控件的父控件对象 let obj = new UiSelector().id(\"p2\").findOne(); let childs = obj.parent();//子控件内容 getDrawingOrder() 返回 {number} 层级 返回当前控件的 绘制层级 let obj = new UiSelector().id(\"p2\").findOne(); let index = obj.getDrawingOrder();//控件绘制层级 isClickable() 返回 {boolean} 是否可以点击，相关的方法还有：isFocusable/isScrollable/isLongClickable/isEnable/isPassword/isEditable/isVisibleToUser/isCheckable/isChecked/isSelected setClickable(bool) 返回 {void} 设置是否可以点击，相关的方法还有：setFocusable/setScrollable/setLongClickable/setEnable/setPassword/setEditable/setVisibleToUser/setCheckable/setChecked/setSelected window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/uiObject/uiObject.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/base/uiObject/uiObject.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-12 09:47:28 "},"advance/dialogs.html":{"url":"advance/dialogs.html","title":"弹窗","keywords":"","body":"弹窗 弹窗主要分为两类，一类当前APP在前台运行，此时使用弹窗，请使用Dialogs弹窗；如果APP已经在后台启动了，Dialogs弹窗将会无法弹出。此时可以使用FloatDialogs弹窗（基于悬浮窗实现，需要开启悬浮窗权限） Dialogs弹窗 show(title, content) str {string} 弹窗标题 content {string|undefined} 弹窗内容，可以不填 返回 void 弹出弹窗 Dialogs.show(\"恭喜你，弹窗成功弹出\"); Dialogs.show(\"温馨提示\", \"恭喜你，弹窗成功弹出\"); input(title, value='') str {string} 弹窗标题 value {string|number} 输入框默认值，可以为空 返回 void 弹出弹窗 let count = Dialogs.input(\"请设置操作次数：\", 5); console.log(count); let account = Dialogs.input(\"请设置账号：\"); console.log(account); confirm(title, content, func) str {string} 弹窗标题 content {string} 说明 func {function} 点击确定或者取消之后，执行的方法 返回 void 弹出弹窗 Dialogs.confirm(\"提示\", \"确定执行吗？\", (result)=>{ if(result){ console.log('点击了确定'); }else{ console.log('点击了取消'); } }); FloatDialogs弹窗 show(title, content='') str {string} 弹窗标题 content {string} 弹窗内容 返回 void 后台弹出弹窗，但是需要开启悬浮窗权限 //heart.js主要启动一个定时器setInterval，每间隔几秒钟往服务器发送当前App的状态 FloatDialogs.show(\"恭喜你，弹窗成功弹出\"); FloatDialogs.show(\"温馨提示\", \"恭喜你，弹窗成功弹出\"); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/dialogs.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/dialogs.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-03 10:18:59 "},"advance/engines/engines.html":{"url":"advance/engines/engines.html","title":"Engines","keywords":"","body":"Engines 首先有必要介绍一下什么是Engines。你可以把Engines理解为JavaScript运行时的管理器。默认情况下，你的JavaScript运行在一个V8环境中。 在某些情况下，你可能需要在你的JavaScript代码中执行一段代码，但是希望这段代码是独立于当前环境（并且不阻塞当前的JavaScript运行）， 这个时候你就会使用Engines来创建一个新的JavaScript运行时，代码将会在一个新的V8环境中运行。 当然，在一些时候，如果你想彻底关闭JavaScript运行时，也是通过Engines来关闭的。 注意，如果你需要使用多线程，可以采用Engines来实现 executeScript(filename) filename {string} 要执行的JS文件地址 必须为相对项目根目录的地址，非当前文件的相对地址 返回 {Thread} 在新的环境中执行JavaScript，新的环境会开启新的堆栈空间，不会和当前的脚本有任何关联，是完全独立的。 比如：你想执行当前脚本的时候，又要定时与服务器进行沟通或者做一些其他事情，可以采用这种方式实现。 //heart.js主要启动一个定时器setInterval，每间隔几秒钟往服务器发送当前App的状态 Engines.executeScript(\"js/heart.js\");//心跳脚本，监测App的在线状态 //特别说明，即使当前脚本终止运行了，heart.js依旧会继续运行 //如果需要关闭heart.js，可以使用 Engines.closeAll方法来操作; executeScript(name, script) name {string} 脚本名称，自定义；实际中的任务名称，用于排查故障的时候使用 script {string} 要执行的脚本内容 返回 {Thread} 在新的环境中执行JavaScript，新的环境会开启新的堆栈空间，不会和当前的脚本有任何关联，是完全独立的。 //heart.js主要启动一个定时器setInterval，每间隔几秒钟往服务器发送当前App的状态 Engines.executeScript(\"My first DeekeScript\", \"console.log('My first DeekeScript');\"); closeAll(bool) bool {boolean} 是否关闭当前脚本，为true则关闭当前脚本，否则只关闭当前脚本以外的脚本 建议在脚本运行完成后进行关闭，否则可能会出现内存泄漏 关闭JavaScript运行时和运行时所在的线程 Engines.closeAll(true);//关闭所有脚本运行时，当前脚本所在运行时也会被结束 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/engines/engines.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/engines/engines.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-14 17:56:59 "},"advance/thread.html":{"url":"advance/thread.html","title":"多线程","keywords":"","body":"多线程 相信富有经验的开发者，会发现很多工具都有提供多线程支持；因为很多时候，我们需要同时执行两个操作（比如，采集直播间弹幕的时候，又要实时获取在线人数）；这个时候使用多线程的方式可以更好地满足我们的需求。DeekeScript本身也是支持多线程的； 特别说明一点，因为DeekeScript底层是基于V8的，而V8是基于单线程的 如果确实需要使用真正意义上的多线程，可以使用Engines来实现 Promise实现异步效果 当然，实际上，还可以通过异步的方式来实现你需要的效果，代码如下： function task1() { return new Promise((resolve) => { setTimeout(() => { console.log('任务1执行完毕'); resolve();// 当任务1完成时，resolve这个Promise }, 1000); }); } function task2() { return new Promise((resolve) => { setTimeout(() => { console.log('任务2执行完毕'); resolve(); }, 1000); }); } task1(); task2(); 如果你需要循环执行某些动作，可以采用setInterval定时器来实现。 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/thread.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/thread.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 15:05:57 "},"advance/module.html":{"url":"advance/module.html","title":"模块","keywords":"","body":"module - 模块 在很多时候，我们的应用可能不止1个JavaScript文件就能实现的，尤其是在构建复杂应用的时候。 在DeekeScript中，可以轻松通过import方法来加载JavaScript文件。下面是一个实例： import与export //项目文件结构如下：项目跟目录下有一个js文件夹和一个task文件夹 //js文件夹中包含了我们需要import的文件，task文件里面有一个dy_toker.js文件 //下面我们在dy_toker.js文件中引用js文件夹下面的a.js和b.js // |> js // | - a.js // | - b.js // |> task // | - dy_toker.js // |DeekeScript.json // js/a.js文件代码如下 export let a = { name: \"我是a.js\", getName(){ return this.name; } } //dy_toker.js代码如下 特别说明，路径是相对于项目根目录的路径 import {a} from \"js/a.js\";//非相对于dy_toker.js文件的路径 console.log(a.getName());//输出 “我是a.js” window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/module.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/module.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 15:18:16 "},"advance/encryption.html":{"url":"advance/encryption.html","title":"加解密","keywords":"","body":"加解密 Enctypt 本模块主要囊如了一些场景的加密方式，和一些编码方式 base64Encode(str) str {string} 需要编码的字符串 返回 {string} base64编码字符串 base64Decode(str) str {string} base64Encode后的字符串 返回 {string} base64解密后的字符串 md5(str) str {string} 加密前的字符串 返回 {string} 加密后的字符串 md5加密 sha1(str) str {string} 加密前的字符串 返回 {string} 加密后的字符串 sha1加密 sha256(str) str {string} 加密前的字符串 返回 {string} 加密后的字符串 sha256加密 aesCbcEncode(key, iv, str) key {string} iv {string} str {string} 需要加密的内容 返回 {string} 加密后的内容 采用AES-CBC加密 let iv = Encrypt.generateIv(); let key = \"sdfsdl\"; let encodeStr = Enctypt.aesCbcEncode(key, iv, str); console.log(encodeStr);//输出加密后的内容 aesCbcDecode(key, iv, encodeStr) key {string} iv {string} str {string} 需要被解密的内容 返回 {string} 解密后的内容 采用AES-CBC模式解密 let iv = Encrypt.generateIv();//替换成实际的iv let key = \"sdfsdl\"; let str = Enctypt.aesCbcEncode(key, iv, encodeStr); console.log(encodeStr);//输出加密后的内容 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/encryption.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/encryption.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-03 09:53:30 "},"advance/photoAndColor.html":{"url":"advance/photoAndColor.html","title":"图片与颜色","keywords":"","body":"图片与颜色 图片识别 等待后续更新 颜色识别 等待后续更新 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/photoAndColor.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/photoAndColor.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 15:59:40 "},"advance/extension/extension.html":{"url":"advance/extension/extension.html","title":"扩展","keywords":"","body":"扩展 DeekeScript将JavaScript运行在Android环境中，很多时候我们需要使用Java的一些类来实现一些能力， 从而弥补JavaScript的一些不足。 默认情况下，DeekeScript已经帮助用户注册了哪些基础的Java类呢？ 下面的类，都默认导入，可以在JavaScript中直接使用 import android.content.Intent; import java.nio.file.Files; import java.io.File; Files类使用 完整例子，请阅读 文件系统-Files console.log(Files.isDir(\"/sdcard/文件夹/\")); //返回false 如何添加其他扩展？ 等待后续更新 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/extension/extension.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/advance/extension/extension.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 15:58:34 "},"backendApi/activationCode.html":{"url":"backendApi/activationCode.html","title":"激活码","keywords":"","body":"后端接口 激活码 需要在DeekeScript.json配置文件中配置Uri请求地址 DeekeScript请求： Request Method: POST Content-Type: application/json 请求参数： { \"activeCode\": \"用户输入的激活码\", \"androidId\": \"系统生成的唯一ID\" //用户卸载App或者恢复出厂设置后，此ID将会变化 } 你的接口需要返回如下json内容： //激活成功 {\"code\": 0, \"status\":\"success\"} //激活失败 {\"code\": 1, \"status\":\"fail\", \"msg\": \"激活失败\"} 激活状态 需要在DeekeScript.json配置文件中配置Uri请求地址，DeekeScript每5分钟请求一次此接口，如果连续2次返回失败，则会强制退出App 并且会发生一个通知给客户（通知内容为接口返回的msg字段内容） DeekeScript请求： Request Method: POST Content-Type: application/json 请求参数： { \"androidId\": \"激活时生成的AndroidId\" } 你的接口需要返回如下json内容： //当前设备具备App使用权限 {\"code\": 0, \"status\":\"success\"} //当前设备不具备App使用权限 {\"code\": 1, \"status\":\"fail\", \"msg\": \"激活码已过期\"} window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/backendApi/activationCode.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/backendApi/activationCode.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:27:36 "},"apk/apk.html":{"url":"apk/apk.html","title":"在线打包","keywords":"","body":"在线打包 在线打包 等待更新 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/apk/apk.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/apk/apk.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:35:15 "},"backend/backend.html":{"url":"backend/backend.html","title":"管理后台支持","keywords":"","body":"管理后台支持 DeekeScript给企业用户提供了后台管理系统支持，可以轻松管理App的激活码，开通代理商等。 界面 等待更新 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/backend/backend.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/backend/backend.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:37:01 "},"cloud/cloud.html":{"url":"cloud/cloud.html","title":"DeekeScript云市场","keywords":"","body":"云市场 云市场作为未来发力的重要模块之一，是DeekeScript接下来着重发展的一部分；但是目前我们团队缺少相关人才， 以至于云市场功能还不能在短期内实现，预计在2024年年底能发布上线。 如果有同学关注这个方向，并且愿意贡献一部分力量，请联系作者（微信：DeekeScript） window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/cloud/cloud.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/cloud/cloud.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:39:35 "},"deeke/deeke.html":{"url":"deeke/deeke.html","title":"嘀客APP","keywords":"","body":"Deeke Deeke地址 可以访问地址：点击访问 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/deeke/deeke.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/deeke/deeke.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:34:54 "},"question/question.html":{"url":"question/question.html","title":"常见问题","keywords":"","body":"问题汇总 DeekeScript未来会支持其他模式吗？ 答：是的，DeekeScript目前对UI部分进行了强制的要求，后续会逐步推出自定义ui的模式 DeekeScript未来会一直维护更新吗？ 答：是的，DeekeScript于2023年年底问世，主要是为了解决底层框架不稳定的问题，后续会持续增加功能，并且会修复历史存在的问题 DeekeScript官方如何联系？ 答：DeekeScript目前是个人在维护与升级，如需联系作者，请添加微信号：DeekeScript；作者可以为你解答一些问题 DeekeScript未来会支持nodejs模式吗？ 答：短期内，DeekeScript不会去兼容nodejs模式 DeekeScript未来会支持Typescript吗？ 答：在未来的一段时间，会逐步提供支持 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/question/question.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/question/question.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-03-11 17:32:46 "},"question/accessibility.html":{"url":"question/accessibility.html","title":"无障碍问题","keywords":"","body":"无障碍问题 在无障碍程序设计过程中，我们和大家一样，遇到最多的问题，就是无障碍的不稳定，接下来主要介绍几个不稳定因素的起因和解决方案。 场景1：APP运行一段时间就挂掉了？ 原因1：目前Android对后台应用限制比较严格，尤其内存不足或者电量不足的时候，会对相关应用进行误杀。 解决方案：关闭手机其他应用、关闭省电模式功能（或者插电运行）、给应用加锁（具体的可以查看对应品牌机型的加锁方法）。 场景2：在页面A点击用户头像进入用户详情页，获取用户数据，最终失败 原因1：某些情况下，当前A页面可能存在多个id相同的头像控件，你的代码拿到的可能不是在当前界面上的控件，导致点击了其他控件 解决方案：增加判断，确保你要获取的id在当前界面，可以通过位置信息确保控件在大概位置（或者判断是否可见等） 原因2：某些情况下，点击头像控件失效了，但是系统确实点击了（这种情况常见于某些APP框架，DeekeScript中暂未发现） 解决方案：在点击的时候，尽可能使用控件的特性，假设控件的clickable为true，则直接使用obj.click()即可；或者发现它的父控件的clickable为true，则直接使用obj.parent().click()；只有在clickable为false的时候，才去使用系统提供的位置点击方法。 原因3：某些情况下被弹窗遮挡了，位置点击的时候跑到其他界面去了 解决方案：对APP的弹窗进行全局的监控，发现之后进行关闭。 原因4：进入A页面的时候，没有设置合理的等待时间，导致头像控件还未加载成功，导致点击失败 解决方案：增加页面的等待时间，如果对速度要求较高，可以先快速操作，发现失败后，再等待操作 场景3：可滑动的用户列表，对其每个用户进行操作时，经常因为返回次数不对，最终找不到用户而出错 原因1：操作用户的时候，国内某些APP框架可能手机卡顿导致返回没有执行（DeekeScript暂未发现） 解决方案：每次返回之后，做一个界面的判断，如果没有返回，则循环再返回 原因2：操作用户的时候，通过点击界面上的“返回”按钮返回，但是因为其他原因导致点击失败 解决方案：尽量使用系统全局的返回，不要使用APP提供的“返回”按钮返回 原因3：因为操作用户的过程中出错了，导致返回异常 解决方案：编写强壮的代码，每一步失败，都做到“心中有数”，然后执行对应的返回操作（或者在执行返回的时候，检测是否到了用户列表页） 场景4：因为某个功能的操作周期比较长，应用程序经常挂掉了 原因1：有时候，我们在开发一款新的APP的时候，经常会有一些超出我们预期的东西，比如：未知的弹窗，未知的界面等等（也包括手机来电等） 解决方案：遇到异常，可以退回到主界面（每退一次检查一次是否进入了主界面），然后再重新运行；当然如果没办法进入主界面，应该也可以进入其他默认的界面，或者自行对当前页面进行判断，然后执行对应操作 注意：尽量不要采用关闭APP，然后重启的方式，因为这种方式很难让客户接受（除非客户接受，并且必须这么做） 场景5：在评论列表或者用户列表出现死循环了 原因1：没有列表已经执行完做判断，或者因为某些原因导致一直在滑动列表 解决方案：对列表执行完成进行判断（DeekeScript中，可以获取对象的_addr属性，比如一次获取到了3个控件，把_addr进行保存，然后滑动之后，再进行读取，与前面的比对，如果相同则认为滑动完成） 对滑动进行判断，超出时间或者次数，进行异常处理 window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/question/accessibility.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/question/accessibility.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-02 10:38:53 "},"INVITE.html":{"url":"INVITE.html","title":"招贤纳士","keywords":"","body":"招贤纳士 DeekeScript需要什么样的人才？ 热爱Coding，热爱生活 有一定的编程能力、文档编写能力 看好DeekeScript的未来 希望通过DeekeScript平台结识更多优秀的人 有较多的空余时间（平均每周至少有6小时） 目前DeekeScript需要的技术人才有：测试工程师、后端工程师（PHP/NodeJs/Java等）、前端工程师、逆向工程师、全栈工程师、UI设计师、平面设计师等 为DeekeScript做出贡献，能获得什么？ 参与DeekeScript的重要事项的讨论 DeekeScript终身会员（2个终身免费账号） 介绍企业客户，可以获得50%分佣 基于DeekeScript开发的应用，优先展示（包括官网展示、本平台上的案例展示） 获得DeekeScript导师身份，从而提升自己的圈内声望 优秀者可以成为DeekeScript合伙人，享受每月的利润（1%-10%）分成 DeekeScript当前有哪些事情需要做？ 下面是当前DeekeScript需要做的工作，如果你有兴趣，可以联系我们 文档维护与更新 视频教程录制（至少使用DeekeScript开发过一个产品） Vscode插件更新与维护、包括代码提示等 开放平台的开发与维护 云市场的开发与维护 产品测试（包括DeekeScript以及其周边产品） 官网的开发维护与更新 旗下子产品Deeke的维护与更新 如何联系DeekeScript官方？ 微信扫码添加（能附带一份简历更佳，这样我们能更清晰地知道你擅长什么） window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/INVITE.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"67bf08545b789c1522cd\",\"clientSecret\":\"d04e46d41828ad4c8db0ddc9e4fa8ad785943260\",\"repo\":\"deekeScriptDoc\",\"owner\":\"miniphper\",\"admin\":[\"miniphper\"],\"id\":\"/INVITE.html\"});gitalk.render(\"gitalk-container\"); Copyright © script.deeke.top 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-04-02 15:35:07 "}}